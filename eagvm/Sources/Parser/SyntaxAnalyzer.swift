import Foundation
final class SA{private var i=0,t=[T]();func a(_ ts:[T])throws->A{self.t=ts;return try p()}private func p()throws->A{var b=[S]();while i<t.count{switch t[i]{case .kw(.class):i+=1;b.append(try c())case .kw(.func):i+=1;b.append(try f())case .semi:i+=1;continue default:b.append(try s())}}return P(b:b)}private func c()throws->A{let n=try v();try e(.curlyOpen);var b=[S]();while t[i] != .curlyClose{b.append(try s())}try e(.curlyClose);return CD(n:n,b:b)}private func f()throws->A{let n=try v();try e(.parenOpen);var ps=[PD]();if t[i] != .parenClose{repeat{ps.append(try pd())}while t[i] == .comma&&({i+=1;return true}())}try e(.parenClose);try e(.curlyOpen);var b=[S]();while t[i] != .curlyClose{b.append(try s())}try e(.curlyClose);return FD(n:n,p:ps,b:b)}private func pd()throws->PD{let n=try v();var t:String?=nil;if t[i] == .colon{i+=1;t=try v()};return PD(n:n,t:t)}private func s()throws->S{switch t[i]{case .kw(.let),.kw(.var):return try vd()case .kw(.if):i+=1;return try is()case .kw(.for):i+=1;return try fs()default:return ES(e:try ex())}}private func vd()throws->S{let k=t[i].desc;i+=1;let n=try v();var t:String?=nil,e:E?=nil;if t[i] == .colon{i+=1;t=try v()};if t[i] == .equal{i+=1;e=try ex()};try e(.semi);return VD(k:k,n:n,t:t,i:e)}private func is()throws->S{let c=try ex();let b=try bs();var a:S?=nil;if t[i] == .kw(.else){i+=1;a=try bs()};return IS(t:c,c:b,a:a)}private func fs()throws->S{try e(.parenOpen);let i=try s(),c=try ex(),u=try ex();try e(.parenClose);return FS(i:i,c:c,u:u,b:try bs())}private func bs()throws->S{try e(.curlyOpen);var b=[S]();while t[i] != .curlyClose{b.append(try s())}try e(.curlyClose);return BS(b:b)}private func ex()throws->E{var l=try p();while[.plus,.minus,.star,.slash].contains(t[i]){let o=t[i].desc;i+=1;l=BE(o:o,l:l,r:try p())}return l}private func p()throws->E{switch t[i]{case .num(let n):i+=1;return LE(n)case .id(let n):i+=1;return IE(n:n)case .parenOpen:i+=1;let e=try ex();try e(.parenClose);return e default:throw PE.unexpected(t[i])}}private func v()throws->String{guard case .id(let n) = t[i] else{throw PE.expectedID};i+=1;return n}private func e(_ tk:T)throws{guard t[i] == tk else{throw PE.expected(tk)};i+=1}}